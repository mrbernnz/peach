# Sessions in Rails

Rails actually has session support built-in (surprise!)

We are going to write a simple app that supports basic authentication using the session.  
Later, we will look at creating users with secure passwords.

First we will create a Rails app called sessions.

`rails new sessions`  
`cd sessions`

Let's add the following routes to our routes file:  
```rb
  get '/login' => 'session#new'
```

Note: We are not creating "resource" routes like yesterday.  
Not all routes need to be "resource" routes, and in this case, our sessions (and secret) are things that don't need to be persisted in the database.  

These routes actually look similar to Sinatra routes, except that instead of having blocks, they take in a Hash with the keys being the routes and the values being controllers and actions.  

`/login` will render a login page that asks for a password.  
We need to add a `Session` controller.  

Create a controller called `SessionController` in `app/controllers`.  
Add the following to it:
```rb
class SessionController < ApplicationController
  def new
		render :new
	end
end
```

Now we need to add a view to that.  Create a file called `app/views/session/new.html.erb`.  Add the following to it:  
```erb
<form action="/session" method="POST">
  <label for = "password">
		Password:
	</label>
	<input name="password" type="password">

	<input name="authenticity_token" value="<%= form_authenticity_token() %>" type="hidden">

	<button>Sign In</button>
</form>
```

We are creating a form that will post to `/session`.  We cannot use `form_for` because we are not dealing with an ActiveRecord model.  
It just has a label and an input field for a password.
We also have an "authenticity" token that will be used with our session.
It's a hidden field, but it creates a random, secure string that will be attached to the cookie that gets created on our session.

Rails supports sessions out of the box but they only support using cookies, and the session token needs to match the token we are setting.

Now we need to add our `/session` route now:  
```rb
  post '/session' => 'session#create'
```

Our `create` method will set the session's `valid_user` key to true if the password matches a pre-set password.  It will also redirect to a "secret page" if the password is correct.

Add the create method to the `SessionController`.

```rb
def create
  if params[:password] == Rails.application.secrets.secret_password
    session[:valid_user] = true
    redirect_to '/secret'
  else
    @error = true
    render :new
  end
end
```

The create method will check if the password equals a pre-defined password.  
If it is, then we set a valid user on the session and redirect to the secret page.  
Otherwise, we set `@error` to true and render the new session page again.

You may be wondering about the `Rails.application.secrets.secret_password` bit.  
Rails includes a file for secrets. This file is inside the `config/` directory and is called `secrets.yml`.  YAML is similar to JSON in that it stores keys and values and is typically used for configuration. It's tab-delimeted, so spaces matter.  The development bit is the only part you should care about.  Underneath the `secret_key_base`, which is used to generate the unique session key, add the following:
`secret_password: peaches`

Do not put more (or less) than 2 spaces in front of it, or it will not work.

Also note that, while this file is automatically generated by Rails, it's not added to .gitignore by default.  You should add this to .gitignore if you plan to use it.

Now that we have our secret password, we can access it using `Rail.application.secrets.secret_password`.

We need to add the `/secret` route and its controller and view.

Route:
```rb
  get '/secret' => 'secret#show'
```

Controller (`app/controllers/secret_controller.rb`):
```rb
class SecretController < ApplicationController

	def show
    valid_user = session[:valid_user]

		if valid_user
			render :show
		else
			redirect_to '/login'
		end
	end
end
```

```erb
<h3> Welcome to the secret page </h3>
```

Now run the server and go to http://localhost:3000/login.  
If you enter the right password, you'll be taken to the "secret page". Otherwise, you get returned to the login page.  

What if we want to destroy this session?  
We need to add a delete session route.  

```rb
  delete '/session' => 'session#destroy'
```

We also need to add a form for logging out to our secret page.  It will look very similar to our create session form, but it will go to the delete version.  

```rb
<h3> Welcome to the secret page </h3>

<form method="POST" action="/session">
	<input name="authenticity_token" value="<%= form_authenticity_token() %>" type="hidden">
	<input name="_method" value="DELETE" type="hidden">
	<button>Logout</button>
</form>
```

Finally, we need an action on the session controller to handle destroying a session.
```rb
	def destroy
		reset_session
		redirect_to '/login'
	end
```

`reset_session` will kill the existing session and then we redirect to the login page to restart the process.


# Using Authentication

What if we want to use actual user authentication and encrypt our password (using Bcrypt, of course)?

The first thing we need to do is install the bcrypt gem.  The good news is, it comes with Rails (albeit, commented out).  Go to your Gemfile and find the following line:  

`# gem 'bcrypt', '~> 3.1.7'`

Remove the comment and run `bundle install` in your directory.

Now we need to generate a user model.  

Run `rails generate model User username:text password_digest:text`

Our user will have a username (stored as text) and a "password digest". Password digest is required for using bcrypt with Rails.

Go to the user model that is generated and add the following:

```rb
 has_secure_password
```

That's basically all we need to save encrypted passwords.

Open your `db/seeds.rb` and create a user:

```rb
User.create(username: 'sam', password: 'password')
```

When this user is created his or her password will be encrypted in the database.

Run our migrations and the seed.
`rake db:migrate`  
`rake db:seed` 

Change your `sessions/new.html.erb` file form to look like this:
```erb
<form action="/session" method="POST">
	<label for="username">
		Username:
		<input name="username">
	</label>
	<label for = "password">
		Password:
		<input name="password" type="password">
	</label>

	<input name="authenticity_token" value="<%= form_authenticity_token() %>" type="hidden">

	<button>Sign In</button>
</form>
```

This form will ask the user for a username and password.  We still have the authenticity_token that will allow us to use sessions in our app.

Now we need to change the create action in our session controller:

```rb
	def create
		user = User.find_by(username: params[:username])

		if user && user.authenticate(params[:password])
			session[:user_id] = user.id
			redirect_to '/secret'
		else 
			@error = true
			render :new
		end
	end
```

First we check for the username in the database. If the user exists, we retrieve it from the database and use the `authenticate` method that is given to us by bcrypt to compare our password with the encrypted version in the database.  After this, we set the `user_id` in the session to our user's id and redirect to the secret page.

Next, we can update the show action in our secret controller:

```rb
def show
		@user = User.find_by(id: session[:user_id])

		if @user
			render :show
		else
			redirect_to '/login'
		end

	end
```

Here we grab the user out of the database using the user_id.  If there is no user (or there is no session), then it will redirect back to the login page. Otherwise, we show the secret page.  

Now we can just add this line to the secret page to show the user's username and we're done!

```erb
<h2> Hello, <%= @user.username %> </h2>
```

# Exercise: Add user authentication to newspaper

Add user authentication to the [newspaper app](../d04/newspaper).  The passwords need to be encrypted, and you can't access /articles without logging in.

**Bonus:** Implement it on all the routes  
**Super Bonus:** Implement it with a before filter: http://guides.rubyonrails.org/action_controller_overview.html#filters
